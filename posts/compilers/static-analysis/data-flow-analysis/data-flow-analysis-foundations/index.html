<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【软件分析笔记】数据流分析：基础与原理篇 | 名声，只是一种糟糕的错觉</title><meta name=keywords content="static analysis"><meta name=description content="格、不动点定理与算法实现优化"><meta name=author content="Noobi"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=https://jiayezheng.tech/images/sl.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jiayezheng.tech/images/sl.png><link rel=icon type=image/png sizes=16x16 href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://jiayezheng.tech/%3Clink%20resources/_gen/images/dio.webp%3E><link rel=mask-icon href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="【软件分析笔记】数据流分析：基础与原理篇"><meta property="og:description" content="格、不动点定理与算法实现优化"><meta property="og:type" content="article"><meta property="og:url" content="http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-analysis-foundations/"><meta property="og:image" content="http://jiayezheng.tech/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-15T11:30:03+00:00"><meta property="article:modified_time" content="2020-09-15T11:30:03+00:00"><meta property="og:site_name" content="后现代主义生活黑客 📚"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jiayezheng.tech/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【软件分析笔记】数据流分析：基础与原理篇"><meta name=twitter:description content="格、不动点定理与算法实现优化"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jiayezheng.tech/posts/"},{"@type":"ListItem","position":2,"name":"【软件分析笔记】数据流分析：基础与原理篇","item":"http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-analysis-foundations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【软件分析笔记】数据流分析：基础与原理篇","name":"【软件分析笔记】数据流分析：基础与原理篇","description":"格、不动点定理与算法实现优化","keywords":["static analysis"],"articleBody":"Data Flow Analysis: Foundations 在应用篇的所有算法，都可以看作是 Iterative Algorithm\n现在，我们从形式化 Formal的角度来审视这些算法：\nA Functional View of Iterative Algorithm   (Define)Given a CFG i.e.: a program with k nodes, the iterative algorithm updates $OUT[n]$ for every node n in each iteration.\n  (Domain)Assume the domain of the values in data flow analysis is $V$, then we can define a K-tuple\n$$ (OUT[n_1],OUT[n_2],…,OUT[n_k]) $$\nas an element of set $(V_1 \\times V_2 \\times … \\times V_k)$ denoted as $V^k$, to hold the values of the analysis after each iteration.\n  (Action)Each iteration can be considered as taking an action to map an element of $V^k$ to a new element of $V^k$, through applying the transfer functions and control-flow handling, abstracted as a function $F: V^k \\to V^k$\n  (Convergence)Then the algorithm outputs a series of k-tuples iteratively util a k-tuple is the same as the last one in 2 consecutive iterations.\n  问题  算法一定会收敛到不动点吗？或者说算法能得到一个解吗？ 若能收敛，那么不动点唯一吗？如果多于一个，那么如何找到最优解？ 算法何时可以收敛到不动点？我们何时可以得到一个解？  数学基础1 Maths Basis I Partial Order 偏序 We define poset as a pair$(P,\\sqsubseteq )$ where $\\sqsubseteq$ is a binary relation that defines a partial ordering over $P$, and $\\sqsubseteq$ has following properties:\n Reflexivity 自反性，$\\forall x \\in P, x \\sqsubseteq x$ Antisymmetry 反自反性，$\\forall x,y \\in P,x \\sqsubseteq y \\wedge y\\sqsubseteq x \\Rightarrow x=y$ Transitivity 传递性，$\\forall x,y,z \\in P,x \\sqsubseteq y \\wedge y\\sqsubseteq z \\Rightarrow x \\sqsubseteq z$  例：A $(S,\\sqsubseteq$) is a poset where $S$ is the power set(幂集) of set $\\{a,b,c\\}$ and $\\sqsubseteq$ represents $\\subseteq$(subset).\n注：这个例子还反应了poset元素的一个原则，要么 $a \\sqsubseteq b$，要么$b \\sqsubseteq a$，要么b与a是不可比较（incomparable，如右图没有箭头连接的集合）的，不存在骑墙者。\nUpper and Lower Bounds 上界与下界 Definition:\nGiven a poset $(P,\\sqsubseteq)$ and its subset $S$ that $S \\subseteq P$, we say that $u \\in P$ is an upper bound of $S$, if $\\forall x \\in S, x \\sqsubseteq u$.\n注1：以上定义用除了上界元素以外的子集定义上界，回想一下函数极值点的定义。\n注2：$x \\sqsubseteq u \\Leftrightarrow x \\leftarrow u$ ，且 $u \\in P, x \\in S$\nSimilarly, $l \\in P$ is a lower bound of $S$, if $\\forall x \\in S, l \\sqsubseteq x$.\n例子：求子集$S$的上界与下界\n 答案：  upper bound: $\\{a,b,c \\}$\nlower bound: $\\{ \\}$\nLeast upper bound 上确界 (also called LUB or join ) of $S$, written $\\sqcup S$,\nif for every upper bound of $S$, say $u$, $\\sqcup S \\sqsubseteq u$\nGreatest lower bound 下确界 (GLB or meet) of $S$, written $\\sqcap S$,\nif for every lower bound of $S$, say $u$, $\\sqcap S \\sqsubseteq u$\n注：上下界是一个集合，而上下确界是单个元素\n**例子：**求子集$S$的上确界与下确界\n  答案：\n$S$的上界：$\\{ \\{a,b,c\\}, \\{a,b\\}\\}$\n那么$S$的上确界：$\\{a,b\\}$\nS的下界：$\\{ \\{\\}\\}$\nS的下确界：$\\{\\}$\n  Special Cases 特殊情况\nUsually, if $S$ contains only two elements $a$ and $b$ ($S={a,b}$), then\n$\\color{red}\\sqcup S$ can be written in $\\color{red}a \\sqcup b$ ( join of $a$ and $b$)\n$\\color{blue}\\sqcap S$ can be written in $\\color{blue}a \\sqcap b$ ( meet of $a$ and $b$)\n注：略微抽象，结合上面的例子进行理解。\nProperties of bounds 界的性质\n  不是所有的牛奶都叫特仑苏，不是所有的poset都有 LUB 或 GLB 唯一性：\n  若一个poset的子集$S$存在LUB或GLB，那么这个子集的LUB和GLB将是唯一的\n  【证明】\n反证法：\n要证明结论，不妨假设偏序集$(P，\\sqsubseteq)$的子集是$S$ s.t. $S$存在 GLB\n且满足存在两个相异的GLB $g_1$ 和 $g_2$。\n由于 $g_1$ , $g_2$ $\\in S$，因此，由 GLB的定义可知：$g_1 \\sqsubseteq g_2$ 且 $g_2 \\sqsubseteq g_1$。\n而根据poset的Antisymmetry性质可知：$\\forall x,y \\in P,x \\sqsubseteq y \\wedge y\\sqsubseteq x \\Rightarrow x=y$\n而$g_1$ 和 $g_2$相异，这与Antisymmetry性质矛盾。\n于是，GLB是唯一的。\n同理可证，LUB也是唯一的。\n$\\blacksquare$\n    Lattice 格 Definition:\nGiven a poset $(P,\\sqsubseteq)$, $\\forall a, b \\in P$, if $a \\sqcup b$ and $a\\sqcap b$ exist, then $(P,\\sqsubseteq)$ is called a lattice.\nIntuition:\nA poset is a lattice if every pair of its elements has a LUB and a GLB.\n例1：$(S,\\sqsubseteq)$ is a lattice where $S$ is a set of integers and $\\sqsubseteq$ represents $\\le$.\n⭕ The $\\sqcup$ equals to $max\\{a,b\\}$\nThe $\\sqcap$ equals to $min\\{a,b\\}$\n例2：$(S,\\sqsubseteq)$ is not a lattice where $S$ is a set of strings , $\\sqsubseteq$ stand for the substring relation.\n❌“pin” $\\sqcup$ “sin” does not exists. 例3：A $(S,\\sqsubseteq$) is a lattice where $S$ is the power set(幂集) of set $\\{a,b,c\\}$ and $\\sqsubseteq$ represents $\\subseteq$(subset).\n⭕ The $\\sqcup$ equals to $\\cup$\nThe $\\sqcap$ equals to $\\cap$ Semi-lattice 半格 Definition:\nGiven a poset $(P,\\sqsubseteq)$, $\\forall a, b \\in P$,\nif only exists $a \\sqcup b$, it is called join semi-lattice.\nif only exists $a\\sqcap b$, it is called meet semi-lattice.\n*Complete lattice Definition:\nGiven a lattice $(P,\\sqsubseteq)$ , for arbitrary subset of $S$ of $P$, if $\\sqcup S$ and $\\sqcap S$ exists, then $(P,\\sqsubseteq)$ is called a complete lattice.\nIntuition:\nAll subsets of a lattice have a LUB and GLB\n例1：$(S,\\sqsubseteq)$ is not a complete lattice where $S$ is a set of integers and $\\sqsubseteq$ represents $\\le$.\n❌ For a subset $S^+$ including all positive integers, it has no $\\sqcup S^+ (+\\infin)$\n*例2：A $(S,\\sqsubseteq$) is a complete lattice where $S$ is the power set(幂集) of set $\\{a,b,c\\}$ and $\\sqsubseteq$ represents $\\subseteq$(subset).\n⭕ The $\\sqcup$ equals to $\\cup$\nThe $\\sqcap$ equals to $\\cap$ Properties:\n  Every complete lattice $(P,\\sqsubseteq)$ has:\n a greatest element $\\top = \\sqcup P$ called top. a least element $\\bot = \\sqcap P$ called bottom.    Every finite lattice (P is finite) is a complete lattice. 有穷格一定是完全格.\n  A complete lattice is not bound to be a finite lattice 完全格不一定是有穷集合\n e.g. : $\\{ x\\in R\\ |\\ 0\\le x \\le1\\}$ is a complete lattice with infinite numbers of elements    Product Lattice  Recall Cartesian product 复习一下笛卡尔积: e.g. Given set $A=\\{a,b\\}$ and $B=\\{1,2,3\\} $, $A \\times B = \\{(a,1),(a,2),(a,3),(b,1),(b,2),(b,3)\\}$\n Definition:\nGiven lattices $L_1 = (P_1, \\sqsubseteq_1)$, $L_2 = (P_2, \\sqsubseteq_2)$, … , $L_n = (P_n, \\sqsubseteq_n)$,\nif $\\forall i$, $(P_n, \\sqsubseteq_n)$ has $\\sqcup_i$ (least upper bound) and $\\sqcap_i$ (greatest lower bound), then\nwe can have a product lattice $L^n = (P, \\sqsubseteq)$ that is defined by:\n $P = P_1 \\times P_2 \\times … \\times P_n$ $(x_1, … , x_n) \\sqsubseteq (y_1, …, y_n) \\Leftrightarrow (x_1 \\sqsubseteq y_1) \\wedge (x_2 \\sqsubseteq y_2) \\wedge … \\wedge (x_n \\sqsubseteq y_n)$  注：右边即同时满足这些关系   $(x_1, … , x_n) \\sqcup (y_1 , …, y_n) =(x_1 \\sqcup y_1 ,…,x_n \\sqcup y_n)$ $(x_1, … , x_n) \\sqcap (y_1 , …, y_n) =(x_1 \\sqcap y_1 ,…,x_n \\sqcap y_n)$  Properties:\n  A product lattice is a lattice.\n注：本身性质不变，仍是格\n  If a product lattice $L^n$ is a product of complete (and finite) lattices, then $L^n$ is also complete (and finite).\n注：作积，完全性与有限性不变\n   Data Flow Analysis Framework via Lattice 以格为基础的数据流分析框架\nFramework in a formal meaning A data flow analysis framework $\\color{black}(\\color{red}D,\\color{green}L,\\color{blue}F \\color{black})$ consists of:\n $\\color{red}D$: a direction of data flow: forwards or backwards $\\color{green}L$: a lattice including domain of the values $V$ and a meet $\\sqcap$ or join $\\sqcup$ operator $\\color{blue} F$: a family of transfer functions i.e. $f: V → V$  Data flow analysis can be seen as iteratively applying transfer functions and meet/join operations on the value of a lattice.\n接下来，就要回答开篇的问题\n 算法一定会收敛到不动点吗？或者说算法能得到一个解吗？ 若能收敛，那么不动点唯一吗？如果多于一个，那么如何找到最优解？ 算法何时可以收敛到不动点？我们何时可以得到一个解？\n 算法一定可以达到不动点吗？ 复习一下，应用篇关于函数单调性的理解。\n我们不动点是所有不动点中最好的吗？又如何定义“最好”？  数学基础2 Math Basis II Monotonicity 单调性 definition:\nA function $f$: $L\\rightarrow L$ ( $L$ is a lattice) is monotonic if $\\forall x, y \\in L, x \\sqsubseteq y \\Rightarrow f(x) \\sqsubseteq f(y)$\nFixed-Point Theorem 不动点定理 Given a complete lattice $(L, \\sqsubseteq)$, if\n $f: L \\rightarrow L$ is monotonic and $L$ is finite, then  the least fixed point of f can be found by iterating\n$f(\\bot), f(f(\\bot)), …, f^k(\\bot)$ until a fixed point is reached.\n 存在性 2. 最小性*  注1：回忆单调有界准则\n注2：这里的最小性是相对于\n  起始点为$\\bot$\n  关于$f$ 迭代的“目标”为May（注意和Forward 和 Backward 无关）\n  的情况而言（回忆May和Must的区别），\n因此这里叫做**最近性（离起始点最近的收敛点）**更好。\n  接下来，证明这个定理。\n【证明】\n先证存在性：\n根据$\\bot$和$f$的定义，我们有：\n$$ \\bot \\sqsubseteq f(\\bot) $$\n又由于 $f$是单调的，我们有：\n$$ f(\\bot) \\sqsubseteq f( f(\\bot)) = f^2(\\bot) $$\n同样地，不停地重复迭代应用 $f$，我们有：\n$$ \\bot \\sqsubseteq f(\\bot) \\sqsubseteq f^2(\\bot)\\sqsubseteq f^3(\\bot)\\sqsubseteq …\\sqsubseteq f^n(\\bot) $$\n又由于 $L$是有限集合，并且\n$$ f(\\top) =\\top $$\n因此，$\\exists k0\\ \\ s.t.$\n$$ f^{Fix}=f^k(\\bot)=f^{k+1} (\\bot) $$\n因此，不动点存在。\n$\\blacksquare$\n再证明最小不动点，反证法：\n假设在不动点$f^k(\\bot)$的基础上，还有一个不动点 $x$ i.e $x = f(x)$\n根据 $\\bot$ 的定义有： $\\bot \\sqsubseteq x$\n数学归纳法：\n 起始条件：因为$f$是单调的，我们有：  $$ f(\\bot) \\sqsubseteq f(x) $$\n 假设 $f^i(\\bot) \\sqsubseteq f^i(x)$ 成立 由于$f$单调，于是$f^{i+1}(\\bot) \\sqsubseteq f^{i+1}(x)$  于是由数学归纳法可知\n$$ f^i(\\bot) \\sqsubseteq f^i(x) $$\n因此，当$f^k(\\bot) \\sqsubseteq f^k(x) = x$ 时，我们有\n$$ f^{Fix} = f^k(\\bot) \\sqsubseteq x $$\n因此，不动点是最小的。\n$\\blacksquare$\n  Now what we have just seen is the property (fixed point theorem) for the function on a lattice.\nWe cannot say our iterative algorithm also has that property unless we can relate the algorithm to the fixed point theorem, if possible.\n要将我们的算法将不动点定理关联上。\n Relate Iterative Algorithm to Fixed Point Theorem Abstraction Consider the k-tuple in Iterative Algorithm as a Product Lattice $L$\n将算法中的 k元组（Bit Vector）抽象为Product Lattice.\n$$ L=(P,\\sqsubseteq)\\ P=(P_1, P_2,…,P_n) $$\n将一个一次iteration的过程抽象为函数$f:L\\to L$\n而整个抽象的过程可以看作复合函数$f^k$\n由于Domain是Product Lattice，我们的根据其定义以及算法的行为，有以下洞见：\n  Transfer Function: $f_i: L \\to L$\n  Join/Meet Function $\\sqcap /\\sqcup: L \\times L \\to L$ （注意这里的$\\times$属于损失严谨性的符号滥用）\ni.e. $(x_1, … , x_n) \\sqcup (y_1 , …, y_n) =(x_1 \\sqcup y_1 ,…,x_n \\sqcup y_n)$   Convergence 收敛存在性  不动点定理： Given a complete lattice $(L, \\sqsubseteq)$, if $f: L \\rightarrow L$ is monotonic and $L$ is finite, then least fixed point of f can be found by iterating.\n   Finite 有界\n由于 Product Lattice的性质：\n If a product lattice $L_p$ is a product of complete (and finite) lattices, i.e., $(L, L, …, L)$, then $L_p$ is also complete (and finite)\n 因此，只要我们巧妙地构造$L$，使得$L$本身是Complete Lattice并且是Finite即可。\n  Monotonic 单调\n讨论 $f:L\\to L$:\n由于$f$的操作为：\n  transfer function:\n由于$gen_B$和$kill_B$为常数，容易证明其单调性。\n  join / meet function$\\sqcup / \\sqcap$:\n    我们证明 2.的单调性\n不妨证明 $\\sqcup$的单调性：\n问题：若 $\\forall x,y,z \\in L, x \\sqsubseteq y$ , 证明 $x \\sqcup y \\sqsubseteq y \\sqcup z$\n【证明】\n根据 $\\sqcup$的定义，有 $y \\sqsubseteq y \\sqcup z$\n又由于 $x \\sqsubseteq x \\sqcup y$ 且 $x \\sqsubseteq y$\n于是有 $x \\sqsubseteq y = y$\n因此，$x \\sqcup y \\sqsubseteq y \\sqcup z$\n同理可证 $\\sqcap$ 也是单调的\n$\\blacksquare$\n    于是，我们解决了前两个问题，即算法收敛性与收敛点唯一性。\n（不动点定理可以一次回答前两个问题）\nPerformance Analysis 性能分析 第三个问题，算法何时收敛，即算法的复杂度如何？\n我们拿前面幂集的图举例：\n我们知道，这是一个Lattice。\n假设$\\top = \\{a,b,c\\} , \\bot = \\{\\}$\n我们定义：格的高度 $h$$\\top$ 到 $\\bot$ 的最多的边数，或者说，最长的路径\ne.g. 右图的 $h = 3$\n假设 Product Lattice $L_k$ 有 k个分量\ne.g. $L_k = (L_1, L_2,…,L_k)$\n考虑一种最坏情况：每个迭代只有**一个分量（满足Lattice性质）**更新，且对于所有分量，都“走”最长的路径。\n容易得到：\n该算法的最坏复杂度为$O(hk)$，其中$h$是格的高度，$k$是Product Lattice的分量数目。\n （重要）May / Must Analysis, a lattice View 我们现在将用Lattice理论解释May 和 Must Analysis背后的原因。仍然用几个问题来鸟瞰以下这个部分\n 为何May Analysis 会找到最小不动点 / 为何Must Analysis 会找到最大不动点？ 为何Must Analysis和May Analysis的初始化各自是那样的？  图例 ⚠️逻辑绕弯警告：\n以Reaching Definition Analysis为例\n 首先回忆：它是一种May Analysis 其次，假设我们正在分析一个程序所有可能 undefined 的变量 从两个极端情况讨论：   当分析算法初始化时，我们将全部的Lattice分量初始化为$\\bot$。\n这说明：在起始态，认为所有的Definition都是无法到达的，即所有的Definition在所有程序点都**无效（undefined）**了。我们认为，这是Unsafe的。\n注：这个unsafe与safe的提法会有歧义，但是形式逻辑上是一致的，暂且按照课程的观点走。\n  当分析算法认为，所有的definition都到达了（111…111），显然，分析程序不会报 warning：xxx variable undefined 。我们认为这是Safe的。\n   而算法的运行过程就是：不断扩大Unsafe（undefined）的范围（由于是Monotonic的），直到一个最优的点（Fixed-point）。  最优：1. （正确）在那一点，会存在误报undefined 情况，但是所有真正undefined 的变量都会包括进来。2. （最好）包括误报的undefined 的范围最小。 这张图很重要，建议收藏！！！    以Available Expression Analysis为例\n 首先，这是Must Analysis 其次，假设我们正在分析一个程序的表达式是否需要在某些BB进行重复计算。 极端情况：   所有的表达式都available，即 所有的表达式都不需要重复计算，我们称所有表达式都Unsafe。\n（简记：不重新计算可能造成结果错误，所以叫Unsafe）\n  没有表达式都available，即 所有的表达式都需要重复计算，即没有优化可能，我们称所有表达式都Safe。\n   算法运行过程：不断扩大Safe的范围（注意⚠️这一点），直到最优的点。  最优：1. （正确）所有的unavailable表达式都被包含进来 2. （最好）保证本可以缓存却被排除的表达式数目最少。    总结：\n 以上两种分析算法，最终都体现了Sound的结果。 对于最小/大的不动点，从另一个角度来看，由于我们设计的算法本身每次迭代的操作够atomic，也就是说步子迈得足够小，于是不动点是最小/最大的。 由于我们transfer function和 join/meet function的合理设计，满足了不动点落在safe区域的条件   How Precise is our Solution? 我们通过介绍一些理想的模型用于对比Iterative Algorithm来衡量Precision。\n（对比OS内存交换的OPT与LRU算法，以及CLRS的竞争性分析）\nMeet-Over-All-Paths Solution (MOP)   什么是MOP？\n定义路径 $P=entry\\to s_1 \\to s_2 \\to …\\to s_i$\n对于路径$P$，定义Transfer Function $F_p=f_{s_1}\\circ f_{s_2} \\circ…\\circ f_{s_i}$\n而$MOP[s_i]$，即将所有从$entry$ 到$s_i$的路径上的transfer function的输出，meet或join起来，找到LUB或GLB，形式化地有：\n$$ MOP[s_i] = \\sqcup / \\sqcap_{A\\ path\\ P\\ from\\ Entry\\ to\\ S_i }F_p(OUT[Entry]) $$\n  MOP的局限性\n 真实程序中，存在CFG中存在，而动态程序中不会到达的分支。 e.g. condition always true 在实现过程中，MOP没有一个明确的收敛点。e.g. 无限循环    MOP vs. Iterative:以may analysis 为例 首先，分别利用表达式概括MOP过程与Iterative 的过程 形式化地：\n$$ Iterative=F(x\\sqcup y)\\ MOP=F(x) \\sqcup F(y) $$\n定理：MOP比我们的方法得到的不动点更准确。\n【证明】\n根据$\\sqcup$的定义有 $x \\sqsubseteq x \\sqcup y$ 以及 $y \\sqsubseteq x \\sqcup y$\n由于$F_P$是单调的，因此有：\n$F(x) \\sqsubseteq F(x\\sqcup y)$ 以及 $F(y) \\sqsubseteq F(x\\sqcup y)$\n又由于\n$F(x) \\sqcup F(y) \\sqsubseteq F(x)$\n于是由传递性：\n$F(x)\\sqcup F(y) \\sqsubseteq F(x\\sqcup y)\\ \\ i.e.\\ MOP \\sqsubseteq Iterative$\n根据不动点与truth点的相对关系，可知$MOP$比$Iterative$更准。\n$\\blacksquare$\n推论：当且仅当$F_P$满足分配律（distributive），$MOP$与$Iterative$的准确度相等\n形式化地，即 $F(x)\\sqcup F(y) = F(x\\sqcup y)$\n Worklist Algorithm 对于，我们还有一些优化的手段，或者说，concrete methods to implementation。\n问题：\n对于Iterative Algorithm， while判断不动点时，存在冗余的计算，如何消除冗余？\nIdea：\n利用一个worklist来保存各个BB的状态，若某个BB已经到达不动点，就踢出worklist。\n否则，就需要计算BB的所有后继节点。\nAlgorithm: Forward Analysis as An Example  复习要点  Understanding Functional View of Iterative Algorithm Lattice and Complete Lattice Fixed-Point Theorem and proof How to summarize may and must analysis in a lattice perspective.(The picture) The relation between MOP and the iterative algorithm by proof. Worklist Algorithm    ","wordCount":"1752","inLanguage":"en","datePublished":"2020-09-15T11:30:03Z","dateModified":"2020-09-15T11:30:03Z","author":{"@type":"Person","name":"Noobi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-analysis-foundations/"},"publisher":{"@type":"Organization","name":"名声，只是一种糟糕的错觉","logo":{"@type":"ImageObject","url":"https://jiayezheng.tech/images/sl.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jiayezheng.tech/ accesskey=h title="名声，只是一种糟糕的错觉 (Alt + H)"><img src=https://jiayezheng.tech/images/sl.png alt=logo aria-label=logo height=35>名声，只是一种糟糕的错觉</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jiayezheng.tech/aboutme/ title=关于我><span>关于我</span></a></li><li><a href=http://jiayezheng.tech/tags/ title=标签><span>标签</span></a></li><li><a href=https://jiayezheng.tech/ title=主页><span>主页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jiayezheng.tech/>Home</a>&nbsp;»&nbsp;<a href=http://jiayezheng.tech/posts/>Posts</a></div><h1 class=post-title>【软件分析笔记】数据流分析：基础与原理篇</h1><div class=post-description>格、不动点定理与算法实现优化</div><div class=post-meta><span title="2020-09-15 11:30:03 +0000 UTC">September 15, 2020</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Noobi&nbsp;|&nbsp;<a href=https://github.com/Xpectuer/my-blog/content/posts/compilers/static-analysis/data-flow-analysis/data-flow-analysis-foundations.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#data-flow-analysis-foundations aria-label="Data Flow Analysis: Foundations">Data Flow Analysis: Foundations</a><ul><ul><li><a href=#a-functional-view-of-iterative-algorithm aria-label="A Functional View of Iterative Algorithm">A Functional View of Iterative Algorithm</a></li><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li></ul><li><a href=#%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%801-maths-basis-i aria-label="数学基础1 Maths Basis I">数学基础1 Maths Basis I</a><ul><li><a href=#partial-order-%e5%81%8f%e5%ba%8f aria-label="Partial Order 偏序">Partial Order 偏序</a></li><li><a href=#upper-and-lower-bounds-%e4%b8%8a%e7%95%8c%e4%b8%8e%e4%b8%8b%e7%95%8c aria-label="Upper and Lower Bounds 上界与下界">Upper and Lower Bounds 上界与下界</a></li><li><a href=#lattice-%e6%a0%bc aria-label="Lattice 格">Lattice 格</a></li><li><a href=#semi-lattice-%e5%8d%8a%e6%a0%bc aria-label="Semi-lattice 半格">Semi-lattice 半格</a></li><li><a href=#complete-lattice aria-label="*Complete lattice">*Complete lattice</a></li><li><a href=#product-lattice aria-label="Product Lattice">Product Lattice</a></li></ul></li><li><a href=#data-flow-analysis-framework-via-lattice aria-label="Data Flow Analysis Framework via Lattice">Data Flow Analysis Framework via Lattice</a><ul><li><a href=#framework-in-a-formal-meaning aria-label="Framework in a formal meaning">Framework in a formal meaning</a></li><li><a href=#%e7%ae%97%e6%b3%95%e4%b8%80%e5%ae%9a%e5%8f%af%e4%bb%a5%e8%be%be%e5%88%b0%e4%b8%8d%e5%8a%a8%e7%82%b9%e5%90%97 aria-label=算法一定可以达到不动点吗？>算法一定可以达到不动点吗？</a></li><li><a href=#%e6%88%91%e4%bb%ac%e4%b8%8d%e5%8a%a8%e7%82%b9%e6%98%af%e6%89%80%e6%9c%89%e4%b8%8d%e5%8a%a8%e7%82%b9%e4%b8%ad%e6%9c%80%e5%a5%bd%e7%9a%84%e5%90%97%e5%8f%88%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e6%9c%80%e5%a5%bd aria-label=我们不动点是所有不动点中最好的吗？又如何定义“最好”？>我们不动点是所有不动点中最好的吗？又如何定义“最好”？</a></li></ul></li><li><a href=#%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%802-math-basis-ii aria-label="数学基础2 Math Basis II">数学基础2 Math Basis II</a><ul><li><a href=#monotonicity-%e5%8d%95%e8%b0%83%e6%80%a7 aria-label="Monotonicity 单调性">Monotonicity 单调性</a></li><li><a href=#fixed-point-theorem-%e4%b8%8d%e5%8a%a8%e7%82%b9%e5%ae%9a%e7%90%86 aria-label="Fixed-Point Theorem 不动点定理">Fixed-Point Theorem 不动点定理</a></li></ul></li><li><a href=#relate-iterative-algorithm-to-fixed-point-theorem aria-label="Relate Iterative Algorithm to Fixed Point Theorem">Relate Iterative Algorithm to Fixed Point Theorem</a><ul><li><a href=#abstraction aria-label=Abstraction>Abstraction</a></li><li><a href=#convergence-%e6%94%b6%e6%95%9b%e5%ad%98%e5%9c%a8%e6%80%a7 aria-label="Convergence 收敛存在性">Convergence 收敛存在性</a></li><li><a href=#performance-analysis-%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 aria-label="Performance Analysis 性能分析">Performance Analysis 性能分析</a></li></ul></li><li><a href=#%e9%87%8d%e8%a6%81may---must-analysis-a-lattice-view aria-label="（重要）May /  Must Analysis, a lattice View">（重要）May / Must Analysis, a lattice View</a><ul><li><a href=#%e5%9b%be%e4%be%8b aria-label=图例>图例</a></li></ul></li><li><a href=#how-precise-is-our-solution aria-label="How Precise is our Solution?">How Precise is our Solution?</a><ul><li><a href=#meet-over-all-paths-solution-mop aria-label="Meet-Over-All-Paths Solution (MOP)">Meet-Over-All-Paths Solution (MOP)</a></li><li><a href=#mop-vs-iterative%e4%bb%a5may-analysis-%e4%b8%ba%e4%be%8b aria-label="MOP vs. Iterative:以may analysis 为例">MOP vs. Iterative:以may analysis 为例</a></li></ul></li><li><a href=#worklist-algorithm aria-label="Worklist Algorithm">Worklist Algorithm</a><ul><li><a href=#algorithm-forward-analysis-as-an-example aria-label="Algorithm: Forward Analysis as An Example">Algorithm: Forward Analysis as An Example</a></li><li><a href=#%e5%a4%8d%e4%b9%a0%e8%a6%81%e7%82%b9 aria-label=复习要点>复习要点</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=data-flow-analysis-foundations>Data Flow Analysis: Foundations<a hidden class=anchor aria-hidden=true href=#data-flow-analysis-foundations>#</a></h1><p>在应用篇的所有算法，都可以看作是 Iterative Algorithm</p><p>现在，我们从形式化 Formal的角度来审视这些算法：</p><h3 id=a-functional-view-of-iterative-algorithm>A Functional View of Iterative Algorithm<a hidden class=anchor aria-hidden=true href=#a-functional-view-of-iterative-algorithm>#</a></h3><ul><li><p>(<strong>Define</strong>)Given a CFG i.e.: a program with k nodes, the iterative algorithm updates $OUT[n]$ for every node n in each iteration.</p></li><li><p>(<strong>Domain</strong>)Assume the <strong>domain</strong> of the values in data flow analysis is $V$, then we can define a K-tuple</p><p>$$
(OUT[n_1],OUT[n_2],&mldr;,OUT[n_k])
$$</p><p>as an element of set $(V_1 \times V_2 \times &mldr; \times V_k)$ denoted as $V^k$, to hold the values of the analysis after <strong>each iteration</strong>.</p></li><li><p>(<strong>Action</strong>)<strong>Each iteration</strong> can be considered as taking an action to map an element of $V^k$ to a new element of $V^k$, through applying the transfer functions and control-flow handling, abstracted as a function $F: V^k \to V^k$</p></li><li><p>(<strong>Convergence</strong>)Then the algorithm outputs a series of k-tuples iteratively util a k-tuple is the same as the last one in 2 consecutive iterations.</p></li></ul><h3 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h3><ul><li>算法一定会收敛到不动点吗？或者说算法能得到一个解吗？</li><li>若能收敛，那么不动点唯一吗？如果多于一个，那么如何找到最优解？</li><li>算法何时可以收敛到不动点？我们何时可以得到一个解？</li></ul><h2 id=数学基础1-maths-basis-i>数学基础1 Maths Basis I<a hidden class=anchor aria-hidden=true href=#数学基础1-maths-basis-i>#</a></h2><h3 id=partial-order-偏序>Partial Order 偏序<a hidden class=anchor aria-hidden=true href=#partial-order-偏序>#</a></h3><p>We define <strong>poset</strong> as a pair$(P,\sqsubseteq )$ where $\sqsubseteq$ is a <strong>binary relation</strong> that defines a partial ordering over $P$, and $\sqsubseteq$ has following properties:</p><ol><li><strong>Reflexivity</strong> 自反性，$\forall x \in P, x \sqsubseteq x$</li><li><strong>Antisymmetry</strong> 反自反性，$\forall x,y \in P,x \sqsubseteq y \wedge y\sqsubseteq x \Rightarrow x=y$</li><li><strong>Transitivity</strong> 传递性，$\forall x,y,z \in P,x \sqsubseteq y \wedge y\sqsubseteq z \Rightarrow x \sqsubseteq z$</li></ol><p><strong>例</strong>：A $(S,\sqsubseteq$) is a <strong>poset</strong> where $S$ is the <strong>power set</strong>(幂集) of set $\{a,b,c\}$ and $\sqsubseteq$ represents $\subseteq$(subset).</p><p>注：这个例子还反应了poset元素的一个原则，要么 $a \sqsubseteq b$，要么$b \sqsubseteq a$，要么b与a是不可比较（incomparable，如右图没有箭头连接的集合）的，不存在骑墙者。</p><h3 id=upper-and-lower-bounds-上界与下界>Upper and Lower Bounds 上界与下界<a hidden class=anchor aria-hidden=true href=#upper-and-lower-bounds-上界与下界>#</a></h3><p><strong>Definition:</strong></p><p>Given a poset $(P,\sqsubseteq)$ and its subset $S$ that $S \subseteq P$, we say that $u \in P$ is an <em><strong>upper bound</strong></em> of <strong>$S$</strong>, if $\forall x \in S, x \sqsubseteq u$.</p><p>注1：以上定义用除了上界元素以外的子集定义上界，回想一下函数极值点的定义。</p><p>注2：$x \sqsubseteq u \Leftrightarrow x \leftarrow u$ ，且 $u \in P, x \in S$</p><p>Similarly, $l \in P$ is a <em><strong>lower bound</strong></em> of <em><strong>$S$,</strong></em> if $\forall x \in S, l \sqsubseteq x$.</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled.png alt=Untitled style=zoom:50%><p><strong>例子</strong>：求子集$S$的上界与下界</p><ul><li><strong>答案：</strong></li></ul><p>upper bound: $\{a,b,c \}$</p><p>lower bound: $\{ \}$</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled%201.png alt=Untitled style=zoom:50%><p><em><strong>Least upper bound 上确界</strong></em> (also called LUB or join ) of $S$, written $\sqcup S$,</p><p>if for every upper bound of $S$, say $u$, $\sqcup S \sqsubseteq u$</p><p><em><strong>Greatest lower bound 下确界</strong></em> (GLB or meet) of $S$, written $\sqcap S$,</p><p>if for every lower bound of $S$, say $u$, $\sqcap S \sqsubseteq u$</p><p>注：上下界是一个集合，而上下确界是单个元素</p><p>**例子：**求子集$S$的上确界与下确界</p><ul><li><p><strong>答案：</strong></p><p>$S$的<strong>上界</strong>：$\{ \{a,b,c\}, \{a,b\}\}$</p><p>那么$S$的<strong>上确界</strong>：$\{a,b\}$</p><p>S的<strong>下界</strong>：$\{ \{\}\}$</p><p>S的<strong>下确界</strong>：$\{\}$</p></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled%202.png alt=Untitled style=zoom:50%><p><em><strong>Special Cases 特殊情况</strong></em></p><p>Usually, if $S$ contains only two elements $a$ and $b$ ($S={a,b}$), then</p><p>$\color{red}\sqcup S$ can be written in $\color{red}a \sqcup b$ ( <strong>join</strong> of $a$ and $b$)</p><p>$\color{blue}\sqcap S$ can be written in $\color{blue}a \sqcap b$ ( meet of $a$ and $b$)</p><p>注：略微抽象，结合上面的例子进行理解。</p><p><em><strong>Properties of bounds 界的性质</strong></em></p><ul><li><p><del>不是所有的牛奶都叫特仑苏</del>，不是所有的poset都有 LUB 或 GLB
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled%203.png alt=Untitled style=zoom:50%>
<strong>唯一性：</strong></p></li><li><p>若一个poset的子集$S$存在LUB或GLB，那么这个子集的LUB和GLB将是<strong>唯一的</strong></p><ul><li><p>【证明】</p><p>反证法：</p><p>要证明结论，不妨假设偏序集$(P，\sqsubseteq)$的子集是$S$ s.t. $S$存在 GLB</p><p>且满足存在两个相异的GLB $g_1$ 和 $g_2$。</p><p>由于 $g_1$ , $g_2$ $\in S$，因此，由 GLB的定义可知：$g_1 \sqsubseteq g_2$ 且 $g_2 \sqsubseteq g_1$。</p><p>而根据poset的<strong>Antisymmetry</strong>性质可知：$\forall x,y \in P,x \sqsubseteq y \wedge y\sqsubseteq x \Rightarrow x=y$</p><p>而$g_1$ 和 $g_2$相异，这与<strong>Antisymmetry</strong>性质矛盾。</p><p>于是，GLB是唯一的。</p><p>同理可证，LUB也是唯一的。</p><p>$\blacksquare$</p></li></ul></li></ul><h3 id=lattice-格>Lattice 格<a hidden class=anchor aria-hidden=true href=#lattice-格>#</a></h3><p><strong>Definition:</strong></p><p>Given a poset $(P,\sqsubseteq)$, $\forall a, b \in P$, if $a \sqcup b$ and $a\sqcap b$ exist, then $(P,\sqsubseteq)$ is called a lattice.</p><p><strong>Intuition:</strong></p><p>A poset is a <em><strong>lattice</strong></em> if <strong>every pair</strong> of its elements has a LUB and a GLB.</p><p>例1：$(S,\sqsubseteq)$ is a <strong>lattice</strong> where $S$ is a set of integers and $\sqsubseteq$ represents $\le$.</p><p>⭕ The $\sqcup$ equals to $max\{a,b\}$</p><p>The $\sqcap$ equals to $min\{a,b\}$</p><p>例2：$(S,\sqsubseteq)$ is <strong>not</strong> a <strong>lattice</strong> where $S$ is a set of strings , $\sqsubseteq$ stand for the substring relation.</p><p>❌“pin” $\sqcup$ “sin” does not exists.
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled%204.png alt=Untitled style=zoom:50%></p><p>例3：A $(S,\sqsubseteq$) is a <strong>lattice</strong> where $S$ is the <strong>power set</strong>(幂集) of set $\{a,b,c\}$ and $\sqsubseteq$ represents $\subseteq$(subset).</p><p>⭕ The $\sqcup$ equals to $\cup$</p><p>The $\sqcap$ equals to $\cap$
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled.png alt=Untitled style=zoom:50%></p><h3 id=semi-lattice-半格>Semi-lattice 半格<a hidden class=anchor aria-hidden=true href=#semi-lattice-半格>#</a></h3><p><strong>Definition:</strong></p><p>Given a poset $(P,\sqsubseteq)$, $\forall a, b \in P$,</p><p>if only exists $a \sqcup b$, it is called <strong>join semi-lattice.</strong></p><p>if only exists $a\sqcap b$, it is called <strong>meet semi-lattice</strong>.</p><h3 id=complete-lattice>*Complete lattice<a hidden class=anchor aria-hidden=true href=#complete-lattice>#</a></h3><p><strong>Definition:</strong></p><p>Given a lattice $(P,\sqsubseteq)$ , for arbitrary subset of $S$ of $P$, if $\sqcup S$ and $\sqcap S$ exists, then $(P,\sqsubseteq)$ is called a <strong>complete lattice</strong>.</p><p><strong>Intuition:</strong></p><p><strong>All subsets</strong> of a lattice have a LUB and GLB</p><p>例1：$(S,\sqsubseteq)$ is <strong>not</strong> a <strong>complete</strong> <strong>lattice</strong> where $S$ is a set of integers and $\sqsubseteq$ represents $\le$.</p><p>❌ For a subset $S^+$ including all positive integers, it has no $\sqcup S^+ (+\infin)$</p><p>*例2：A $(S,\sqsubseteq$) is a <strong>complete</strong> <strong>lattice</strong> where $S$ is the <strong>power set</strong>(幂集) of set $\{a,b,c\}$ and $\sqsubseteq$ represents $\subseteq$(subset).</p><p>⭕ The $\sqcup$ equals to $\cup$</p><p>The $\sqcap$ equals to $\cap$
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled.png alt=Untitled style=zoom:50%>
<strong>Properties:</strong></p><ul><li><p>Every <strong>complete lattice $(P,\sqsubseteq)$</strong> has:</p><ul><li>a greatest element $\top = \sqcup P$ called top.</li><li>a least element $\bot = \sqcap P$ called bottom.</li></ul></li><li><p>Every <strong>finite</strong> lattice (P is finite) is a complete lattice. 有穷格一定是完全格.</p></li><li><p>A complete lattice is not bound to be a <strong>finite lattice</strong> 完全格不一定是有穷集合</p><ul><li>e.g. : $\{ x\in R\ |\ 0\le x \le1\}$ is a complete lattice with infinite numbers of elements</li></ul></li></ul><h3 id=product-lattice>Product Lattice<a hidden class=anchor aria-hidden=true href=#product-lattice>#</a></h3><blockquote><p><strong>Recall Cartesian product 复习一下笛卡尔积:</strong>
e.g. Given set $A=\{a,b\}$ and $B=\{1,2,3\} $,
$A \times B = \{(a,1),(a,2),(a,3),(b,1),(b,2),(b,3)\}$</p></blockquote><p><strong>Definition:</strong></p><p>Given lattices $L_1 = (P_1, \sqsubseteq_1)$, $L_2 = (P_2, \sqsubseteq_2)$, &mldr; , $L_n = (P_n, \sqsubseteq_n)$,</p><p>if $\forall i$, $(P_n, \sqsubseteq_n)$ has $\sqcup_i$ (least upper bound) and $\sqcap_i$ (greatest lower bound), then</p><p>we can have a <strong>product lattice</strong> $L^n = (P, \sqsubseteq)$ that is defined by:</p><ul><li>$P = P_1 \times P_2 \times &mldr; \times P_n$</li><li>$(x_1, &mldr; , x_n) \sqsubseteq (y_1, &mldr;, y_n) \Leftrightarrow (x_1 \sqsubseteq y_1) \wedge (x_2 \sqsubseteq y_2) \wedge &mldr; \wedge (x_n \sqsubseteq y_n)$<ul><li>注：右边即同时满足这些关系</li></ul></li><li>$(x_1, &mldr; , x_n) \sqcup (y_1 , &mldr;, y_n) =(x_1 \sqcup y_1 ,&mldr;,x_n \sqcup y_n)$</li><li>$(x_1, &mldr; , x_n) \sqcap (y_1 , &mldr;, y_n) =(x_1 \sqcap y_1 ,&mldr;,x_n \sqcap y_n)$</li></ul><p><strong>Properties:</strong></p><ul><li><p>A product lattice is a lattice.</p><p>注：本身性质不变，仍是格</p></li><li><p>If a product lattice $L^n$ is a product of <strong>complete (and finite) lattices</strong>, then $L^n$ is also <strong>complete (and finite)</strong>.</p><p>注：作积，完全性与有限性不变</p></li></ul><hr><h2 id=data-flow-analysis-framework-via-lattice>Data Flow Analysis Framework via Lattice<a hidden class=anchor aria-hidden=true href=#data-flow-analysis-framework-via-lattice>#</a></h2><p><strong>以格为基础的数据流分析框架</strong></p><h3 id=framework-in-a-formal-meaning>Framework in a formal meaning<a hidden class=anchor aria-hidden=true href=#framework-in-a-formal-meaning>#</a></h3><p>A data flow analysis framework $\color{black}(\color{red}D,\color{green}L,\color{blue}F \color{black})$ consists of:</p><ul><li>$\color{red}D$: a <strong>direction</strong> of data flow: forwards or backwards</li><li>$\color{green}L$: a <strong>lattice</strong> including domain of the values $V$ and a meet $\sqcap$ or join $\sqcup$ operator</li><li>$\color{blue} F$: a family of <strong>transfer functions</strong> i.e. $f: V → V$</li></ul><p>Data flow analysis can be seen as iteratively applying <strong>transfer functions</strong> and <strong>meet/join operations</strong> on the value of a <strong>lattice.</strong></p><p>接下来，就要回答开篇的问题</p><blockquote><p>算法一定会收敛到不动点吗？或者说算法能得到一个解吗？
若能收敛，那么不动点唯一吗？如果多于一个，那么如何找到最优解？
算法何时可以收敛到不动点？我们何时可以得到一个解？</p></blockquote><h3 id=算法一定可以达到不动点吗>算法一定可以达到不动点吗？<a hidden class=anchor aria-hidden=true href=#算法一定可以达到不动点吗>#</a></h3><p>复习一下，应用篇关于<a href=https://www.notion.so/Data-Flow-Analysis-Applications-7435efbbd0114affbcc9788fc437fe43>函数单调性</a>的理解。</p><h3 id=我们不动点是所有不动点中最好的吗又如何定义最好>我们不动点是所有不动点中最好的吗？又如何定义“最好”？<a hidden class=anchor aria-hidden=true href=#我们不动点是所有不动点中最好的吗又如何定义最好>#</a></h3><hr><h2 id=数学基础2-math-basis-ii>数学基础2 Math Basis II<a hidden class=anchor aria-hidden=true href=#数学基础2-math-basis-ii>#</a></h2><h3 id=monotonicity-单调性>Monotonicity 单调性<a hidden class=anchor aria-hidden=true href=#monotonicity-单调性>#</a></h3><p><strong>definition:</strong></p><p>A function $f$: $L\rightarrow L$ ( $L$ is a lattice) is <strong>monotonic</strong> if $\forall x, y \in L, x \sqsubseteq y \Rightarrow f(x) \sqsubseteq f(y)$</p><h3 id=fixed-point-theorem-不动点定理>Fixed-Point Theorem 不动点定理<a hidden class=anchor aria-hidden=true href=#fixed-point-theorem-不动点定理>#</a></h3><p>Given a <strong>complete lattice</strong> $(L, \sqsubseteq)$, if</p><ol><li>$f: L \rightarrow L$ is monotonic and</li><li>$L$ is finite, then</li></ol><p>the least fixed point of f can be found by iterating</p><p>$f(\bot), f(f(\bot)), &mldr;, f^k(\bot)$ until a fixed point is reached.</p><ol><li><strong>存在性</strong> 2. <strong>最小性</strong>*</li></ol><p>注1：回忆单调有界准则</p><p>注2：这里的<strong>最小性</strong>是相对于</p><ol><li><p><strong>起始点为$\bot$</strong></p></li><li><p>关于$f$ 迭代的“目标”为May（注意和Forward 和 Backward <strong>无关</strong>）</p></li></ol><p>的情况而言（回忆May和Must的区别），</p><p>因此这里叫做**最近性（离起始点最近的收敛点）**更好。</p><ul><li><p>接下来，证明这个定理。</p><p>【证明】</p><p>先证<strong>存在性</strong>：</p><p>根据$\bot$和$f$的定义，我们有：</p><p>$$
\bot \sqsubseteq f(\bot)
$$</p><p>又由于 $f$是单调的，我们有：</p><p>$$
f(\bot) \sqsubseteq f( f(\bot)) = f^2(\bot)
$$</p><p>同样地，不停地重复迭代应用 $f$，我们有：</p><p>$$
\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq f^3(\bot)\sqsubseteq &mldr;\sqsubseteq f^n(\bot)
$$</p><p>又由于 $L$是有限集合，并且</p><p>$$
f(\top) =\top
$$</p><p>因此，$\exists k>0\ \ s.t.$</p><p>$$
f^{Fix}=f^k(\bot)=f^{k+1} (\bot)
$$</p><p>因此，不动点存在。</p><p>$\blacksquare$</p><p>再证明<strong>最小不动点</strong>，反证法：</p><p>假设在不动点$f^k(\bot)$的基础上，还有一个不动点 $x$ i.e $x = f(x)$</p><p>根据 $\bot$ 的定义有： $\bot \sqsubseteq x$</p><p>数学归纳法：</p><ul><li>起始条件：因为$f$是单调的，我们有：</li></ul><p>$$
f(\bot) \sqsubseteq f(x)
$$</p><ul><li>假设 $f^i(\bot) \sqsubseteq f^i(x)$ 成立</li><li>由于$f$单调，于是$f^{i+1}(\bot) \sqsubseteq f^{i+1}(x)$</li></ul><p>于是由数学归纳法可知</p><p>$$
f^i(\bot) \sqsubseteq f^i(x)
$$</p><p>因此，当$f^k(\bot) \sqsubseteq f^k(x) = x$ 时，我们有</p><p>$$
f^{Fix} = f^k(\bot) \sqsubseteq x
$$</p><p>因此，不动点是最小的。</p><p>$\blacksquare$</p></li></ul><p>Now what we have just seen is the property (fixed point theorem) for the <strong>function on a lattice.</strong></p><p>We cannot say our iterative algorithm also has that property unless we can <strong>relate</strong> the algorithm to the fixed point theorem, if possible.</p><p>要将我们的算法将不动点定理关联上。</p><hr><h2 id=relate-iterative-algorithm-to-fixed-point-theorem>Relate Iterative Algorithm to Fixed Point Theorem<a hidden class=anchor aria-hidden=true href=#relate-iterative-algorithm-to-fixed-point-theorem>#</a></h2><h3 id=abstraction>Abstraction<a hidden class=anchor aria-hidden=true href=#abstraction>#</a></h3><p>Consider the k-tuple in Iterative Algorithm as a <strong>Product Lattice $L$</strong></p><p>将算法中的 k元组（Bit Vector）抽象为Product Lattice.</p><p>$$
L=(P,\sqsubseteq)\
P=(P_1, P_2,&mldr;,P_n)
$$</p><p>将一个一次iteration的过程抽象为函数$f:L\to L$</p><p>而整个抽象的过程可以看作复合函数$f^k$</p><p>由于Domain是Product Lattice，我们的根据其定义以及算法的行为，有以下洞见：</p><ol><li><p><strong>Transfer Function:</strong> $f_i: L \to L$</p></li><li><p><strong>Join/Meet Function</strong> $\sqcap /\sqcup: L \times L \to L$ （注意这里的$\times$属于损失严谨性的符号滥用）</p><p>i.e. $(x_1, &mldr; , x_n) \sqcup (y_1 , &mldr;, y_n) =(x_1 \sqcup y_1 ,&mldr;,x_n \sqcup y_n)$
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-09_%E4%B8%8B%E5%8D%8812.39.36.png alt="截屏2022-01-09 下午12.39.36.png" style=zoom:50%></p></li></ol><h3 id=convergence-收敛存在性>Convergence 收敛存在性<a hidden class=anchor aria-hidden=true href=#convergence-收敛存在性>#</a></h3><blockquote><p>不动点定理：
Given a <strong>complete lattice</strong> $(L, \sqsubseteq)$, if $f: L \rightarrow L$ is monotonic and $L$ is finite, then least fixed point of f can be found by iterating.</p></blockquote><ul><li><p><strong>Finite 有界</strong></p><p>由于 Product Lattice的性质：</p><blockquote><p>If a product lattice $L_p$ is a product of complete (and finite) lattices, i.e., $(L, L, &mldr;, L)$, then $L_p$ is also complete (and finite)</p></blockquote><p>因此，只要我们巧妙地构造$L$，使得$L$本身是Complete Lattice并且是Finite即可。</p></li><li><p><strong>Monotonic 单调</strong></p><p>讨论 $f:L\to L$:</p><p>由于$f$的操作为：</p><ol><li><p>transfer function:</p><p>由于$gen_B$和$kill_B$为常数，容易证明其单调性。</p></li><li><p>join / meet function$\sqcup / \sqcap$:</p></li></ol><ul><li><p>我们证明 2.的单调性</p><p>不妨证明 $\sqcup$的单调性：</p><p>问题：若 $\forall x,y,z \in L, x \sqsubseteq y$ , 证明 $x \sqcup y \sqsubseteq y \sqcup z$</p><p>【证明】</p><p>根据 $\sqcup$的定义，有 $y \sqsubseteq y \sqcup z$</p><p>又由于 $x \sqsubseteq x \sqcup y$ 且 $x \sqsubseteq y$</p><p>于是有 $x \sqsubseteq y = y$</p><p>因此，$x \sqcup y \sqsubseteq y \sqcup z$</p><p>同理可证 $\sqcap$ 也是单调的</p><p>$\blacksquare$</p></li></ul></li></ul><p>于是，我们解决了前两个问题，即算法收敛性与收敛点唯一性。</p><p>（不动点定理可以一次回答前两个问题）</p><h3 id=performance-analysis-性能分析>Performance Analysis 性能分析<a hidden class=anchor aria-hidden=true href=#performance-analysis-性能分析>#</a></h3><p>第三个问题，算法何时收敛，即算法的复杂度如何？</p><p>我们拿前面<strong>幂集</strong>的图举例：</p><p>我们知道，这是一个Lattice。</p><p>假设$\top = \{a,b,c\} , \bot = \{\}$</p><p>我们定义：格的高度 $h$$\top$ 到 $\bot$ 的<strong>最多的边数，或者说，最长的路径</strong></p><p>e.g. 右图的 $h = 3$</p><p>假设 <strong>Product Lattice</strong> $L_k$ 有 k个分量</p><p>e.g. $L_k = (L_1, L_2,&mldr;,L_k)$</p><p>考虑一种<strong>最坏情况</strong>：每个迭代只有**一个分量（满足Lattice性质）**更新，且对于所有分量，都“走”最长的路径。</p><p>容易得到：</p><p>该算法的最坏复杂度为$O(hk)$，其中$h$是格的高度，$k$是<strong>Product Lattice</strong>的分量数目。</p><h2 id=hahahugoshortcode-s8-hbhb><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/Untitled.png alt=Untitled style=zoom:50%></h2><h2 id=重要may---must-analysis-a-lattice-view>（重要）May / Must Analysis, a lattice View<a hidden class=anchor aria-hidden=true href=#重要may---must-analysis-a-lattice-view>#</a></h2><p>我们现在将用Lattice理论解释May 和 Must Analysis背后的原因。仍然用几个问题来鸟瞰以下这个部分</p><ul><li>为何May Analysis 会找到最小不动点 / 为何Must Analysis 会找到最大不动点？</li><li>为何Must Analysis和May Analysis的初始化各自是那样的？</li></ul><h3 id=图例>图例<a hidden class=anchor aria-hidden=true href=#图例>#</a></h3><p>⚠️逻辑绕弯警告：</p><p><strong>以Reaching Definition Analysis为例</strong></p><ul><li>首先回忆：它是一种May Analysis</li><li>其次，假设我们正在分析一个程序所有可能 <code>undefined</code> 的变量</li><li>从两个<strong>极端情况</strong>讨论：<ol><li><p>当分析算法<strong>初始化</strong>时，我们将全部的Lattice分量初始化为$\bot$。</p><p>这说明：在起始态，认为所有的Definition都是<strong>无法到达</strong>的，即所有的Definition在所有程序点都**无效（<code>undefined</code>）**了。我们认为，这是Unsafe的。</p><p>注：这个unsafe与safe的提法会有歧义，但是形式逻辑上是一致的，暂且按照课程的观点走。</p></li><li><p>当分析算法认为，所有的definition<strong>都到达了</strong>（111&mldr;111），显然，分析程序不会报 <code>warning：xxx variable undefined</code> 。我们认为这是Safe的。</p></li></ol></li><li>而算法的<strong>运行过程</strong>就是：不断扩大Unsafe（<code>undefined</code>）的范围（由于是Monotonic的），直到一个<strong>最优</strong>的点（Fixed-point）。<ul><li>最优：1. （正确）在那一点，会存在误报<code>undefined</code> 情况，但是所有真正<code>undefined</code> 的变量<strong>都会包括进来</strong>。2. （最好）包括<strong>误报</strong>的<code>undefined</code> 的范围最小。
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-09_%E4%B8%8B%E5%8D%882.43.57.png alt=这张图很重要，建议收藏！！！ style=zoom:50%>
这张图很重要，建议收藏！！！</li></ul></li></ul><p><strong>以Available Expression Analysis为例</strong></p><ul><li>首先，这是Must Analysis</li><li>其次，假设我们正在分析一个程序的表达式是否需要在某些BB进行<strong>重复计算</strong>。</li><li>极端情况：<ol><li><p>所有的表达式都available，即 所有的表达式<strong>都不需要</strong>重复计算，我们称所有表达式都Unsafe。</p><p>（简记：不重新计算可能造成<strong>结果错误</strong>，所以叫Unsafe）</p></li><li><p>没有表达式都available，即 所有的表达式<strong>都需要</strong>重复计算，即<strong>没有优化可能</strong>，我们称所有表达式都Safe。</p></li></ol></li><li>算法运行过程：不断扩大Safe的范围（注意⚠️这一点），直到最优的点。<ul><li>最优：1. （正确）所有的unavailable表达式都被包含进来 2. （最好）保证本可以<strong>缓存</strong>却被排除的表达式数目最少。</li></ul></li></ul><p><strong>总结：</strong></p><ul><li>以上两种分析算法，最终都体现了<strong>Sound</strong>的结果。</li><li>对于最小/大的不动点，从另一个角度来看，由于我们设计的算法本身每次迭代的操作够atomic，也就是说步子迈得足够小，于是不动点是最小/最大的。</li><li>由于我们transfer function和 join/meet function的合理设计，满足了不动点落在safe区域的条件</li></ul><hr><h2 id=how-precise-is-our-solution>How Precise is our Solution?<a hidden class=anchor aria-hidden=true href=#how-precise-is-our-solution>#</a></h2><p>我们通过介绍一些<strong>理想的模型</strong>用于对比Iterative Algorithm来衡量Precision。</p><p>（对比OS内存交换的OPT与LRU算法，以及CLRS的竞争性分析）</p><h3 id=meet-over-all-paths-solution-mop>Meet-Over-All-Paths Solution (MOP)<a hidden class=anchor aria-hidden=true href=#meet-over-all-paths-solution-mop>#</a></h3><ul><li><p>什么是MOP？</p><p>定义路径 $P=entry\to s_1 \to s_2 \to &mldr;\to s_i$</p><p>对于路径$P$，定义Transfer Function $F_p=f_{s_1}\circ f_{s_2} \circ&mldr;\circ f_{s_i}$</p><p>而$MOP[s_i]$，即将所有从$entry$ 到$s_i$的路径上的transfer function的输出，meet或join起来，找到LUB或GLB，形式化地有：</p><p>$$
MOP[s_i] = \sqcup / \sqcap_{A\ path\ P\ from\ Entry\ to\ S_i }F_p(OUT[Entry])
$$</p></li><li><p>MOP的局限性</p><ul><li>真实程序中，存在CFG中存在，而动态程序中不会到达的分支。 e.g. <code>condition always true</code></li><li>在实现过程中，MOP没有一个明确的收敛点。e.g. 无限循环</li></ul></li></ul><h3 id=mop-vs-iterative以may-analysis-为例>MOP vs. Iterative:以may analysis 为例<a hidden class=anchor aria-hidden=true href=#mop-vs-iterative以may-analysis-为例>#</a></h3><p>首先，分别利用表达式概括MOP过程与Iterative 的过程
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-09_%E4%B8%8B%E5%8D%884.44.19.png alt="截屏2022-01-09 下午4.44.19.png" style=zoom:50%>
形式化地：</p><p>$$
Iterative=F(x\sqcup y)\
MOP=F(x) \sqcup F(y)
$$</p><p><strong>定理</strong>：MOP比我们的方法得到的不动点更准确。</p><p>【证明】</p><p>根据$\sqcup$的定义有 $x \sqsubseteq x \sqcup y$ 以及 $y \sqsubseteq x \sqcup y$</p><p>由于$F_P$是单调的，因此有：</p><p>$F(x) \sqsubseteq F(x\sqcup y)$ 以及 $F(y) \sqsubseteq F(x\sqcup y)$</p><p>又由于</p><p>$F(x) \sqcup F(y) \sqsubseteq F(x)$</p><p>于是由<strong>传递性</strong>：</p><p>$F(x)\sqcup F(y) \sqsubseteq F(x\sqcup y)\ \ i.e.\ MOP \sqsubseteq Iterative$</p><p>根据不动点与truth点的相对关系，可知$MOP$比$Iterative$<strong>更准。</strong></p><p>$\blacksquare$</p><p><strong>推论：<strong>当且仅当$<strong>F_P</strong>$满足</strong>分配律</strong>（distributive），<strong>$MOP$与$Iterative$的准确度相等</strong></p><p>形式化地，即 $F(x)\sqcup F(y) = F(x\sqcup y)$</p><hr><h2 id=worklist-algorithm>Worklist Algorithm<a hidden class=anchor aria-hidden=true href=#worklist-algorithm>#</a></h2><p>对于，我们还有一些<strong>优化</strong>的手段，或者说，concrete methods to implementation。</p><p><strong>问题：</strong></p><p>对于<strong>Iterative Algorithm， while判断不动点时</strong>，存在冗余的计算，如何消除冗余？</p><p><strong>Idea：</strong></p><p>利用一个worklist来保存各个BB的状态，若某个BB已经到达不动点，就踢出worklist。</p><p>否则，就需要计算BB的所有后继节点。</p><h3 id=algorithm-forward-analysis-as-an-example>Algorithm: Forward Analysis as An Example<a hidden class=anchor aria-hidden=true href=#algorithm-forward-analysis-as-an-example>#</a></h3><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/algorithm.png alt=algorithm><hr><h3 id=复习要点>复习要点<a hidden class=anchor aria-hidden=true href=#复习要点>#</a></h3><ul><li>Understanding Functional View of Iterative Algorithm</li><li>Lattice and Complete Lattice</li><li>Fixed-Point Theorem and proof</li><li>How to summarize may and must analysis in a lattice perspective.(The picture)</li><li>The relation between MOP and the iterative algorithm by proof.</li><li>Worklist Algorithm</text></alt></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://jiayezheng.tech/tags/static-analysis/>static analysis</a></li></ul><nav class=paginav><a class=prev href=http://jiayezheng.tech/posts/compilers/java/java-value-type/java_value_type/><span class=title>« Prev Page</span><br><span>【碎碎念】读《Java有值类型吗？》有感</span></a>
<a class=next href=http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-anlaysis-applications/><span class=title>Next Page »</span><br><span>【软件分析笔记】数据流分析：应用篇</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jiayezheng.tech/>名声，只是一种糟糕的错觉</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>