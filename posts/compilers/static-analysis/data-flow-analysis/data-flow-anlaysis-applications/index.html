<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【软件分析笔记】数据流分析：应用篇 | 名声，只是一种糟糕的错觉</title><meta name=keywords content="static analysis"><meta name=description content="介绍典型的数据流分析算法"><meta name=author content="Noobi"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=https://jiayezheng.tech/images/sl.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jiayezheng.tech/images/sl.png><link rel=icon type=image/png sizes=16x16 href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://jiayezheng.tech/%3Clink%20resources/_gen/images/dio.webp%3E><link rel=mask-icon href=http://jiayezheng.tech/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.99.1"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="【软件分析笔记】数据流分析：应用篇"><meta property="og:description" content="介绍典型的数据流分析算法"><meta property="og:type" content="article"><meta property="og:url" content="http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-anlaysis-applications/"><meta property="og:image" content="http://jiayezheng.tech/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-15T11:30:03+00:00"><meta property="article:modified_time" content="2020-09-15T11:30:03+00:00"><meta property="og:site_name" content="后现代主义生活黑客 📚"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://jiayezheng.tech/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【软件分析笔记】数据流分析：应用篇"><meta name=twitter:description content="介绍典型的数据流分析算法"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://jiayezheng.tech/posts/"},{"@type":"ListItem","position":2,"name":"【软件分析笔记】数据流分析：应用篇","item":"http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-anlaysis-applications/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【软件分析笔记】数据流分析：应用篇","name":"【软件分析笔记】数据流分析：应用篇","description":"介绍典型的数据流分析算法","keywords":["static analysis"],"articleBody":"Data Flow Analysis：Applications Overview What is Data Flow Analysis ?\nHow application-specific Data flows on CFG with safe approximation.\n分析算法感兴趣的数据如何流经控制流图。\n CFG  Nodes (Basic Blocks) 基本块 Edges (Control Flow) 控制流 CFG(a program) 整个程序   Safe Approximation  safe approximation for different purposes 不同的分析目的，对于safe有不同的定义:\n Must Analysis：Under Approximation May Analysis: Over Approximation  相同点：这两种目的往往殊途同归地达到Soundness。\n不同的目的对应了不同的手段：1. Data Abstraction 2. Approximation Strategies i.e. transfer functions \u0026 control flow handling.\n Preliminaries for Data Flow Analysis Input \u0026 Output States Definition:\n$IN[s]\\ OUT[s]$ stand for input \u0026 output states of program points i.e. before and after executing the IR statements $s$ respectively.\ne.g.:\n 下面是最简单的程序点的示意图。包括：  $s_1$的输入/输出状态 $s_1$的语句 程序点，包括状态信息      语句之间的状态关系1：\n下面表示两个顺序的语句之间状态关系。\n即，$s_2$的输入是$s_1$的输出\n$IN[s_2]=OUT[s_1]$\n    带有控制流的语句间的状态关系1：\n右图表示了一种分支语句的状态关系\n    带有控制流的语句间的状态关系2：\n下图是分支合并语句的状态关系，引入了操作符$\\wedge$，表示语句分支的合并   Domain 值域  In each data-flow analysis application, we associate with every program point a data-flow value that represents abstraction of the set of all possible program states that can be observed for that point.\n data-flow value: Abstraction of the set of all possible program states that can be observed for that point.\n于是，我们把 data flow value在一个程序中可能取值的集合称作 Domain.\nData flow analysis: another perspective Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the $IN[s]$ and $OUT[s]$, for all statements $s$.\n constraints  transfer functions flow of control   solution  related data flow value for each program points of statement $s$.    Notations for Transfer Functions’s Constrains  Forward Analysis  $OUT[s] = f_s(IN[s])$\n Backward Analysis  $IN[s] = f_s(OUT[s])$\nNotations for Control Flow’s Constraints   Control flow within a BB\n$IN[s_{i+1}]=OUT[s_i], \\forall i=1,2,3,…,n-1$\n  Control flow among BBs\n$IN[B] = IN[s_1]$\n 注：BB的入口是BB第一个语句的入口\n $OUT[B]=OUT[s_n]$\n 注：BB的出口是BB最后一个语句的出口\n $OUT[B] = f_B(IN[B]), f_B = f_{sn} \\circ … \\circ f_{s2} \\circ f_{s1}$\n 注：$\\circ$ 表示函数的复合\n $IN[B]=\\bigwedge_{\\color{red}P\\\\ a\\ predecessor\\ of\\ \\color{blue} B}^{} OUT[P]$\n 注：分支合并B的输入等于B所有前驱节点输出状态 meet 的结果\n    Reaching Definitions Analysis Definition:\nA statement that assign a value to $v$. 一条对$v$的赋值语句。\nReaching Definition:\n Definition of variable $v$ at program point $p$ reaches point $q$ if there is a path from p to $q$ s.t. no new definition of $v$ appears on that path.\n Reaching Definition：变量$v$在从程序点$p$到程序点 $q$到过程中未被重新定义。\n应用   Detecting possible undefined variables. 检查undefined变量\nE.g.: Introduce a dummy definition for each variable. If any at point $p$, definition of variable $v$ is dummy, then it is undefined.\ne.g.: Application in Optimization: Check if the variable\n  Abstraction   Data Flow Values / Facts\n The definition of all the variables in a program. represented by Bit Vectors  e.g.: $D_1, D_2, D_3, …, D_{100}$ (100 definitions)\n[ 0000...0 ]  Bit $i$ from the left represents definition $D_i$\n  Safe-Approximation 考虑语句：\nD: v = x op y 本条语句将程序中 $v$ 的其他定义去除，其他变量的定义不受影响。\n  Transfer function 数学语言表达\n$$OUT[B] = gen_B \\cup (IN[B] - kill_B)$$\n其中$gen_B$基本块$B$产生的definition的集合\n$kill_B$代表所有$B$以外基本块对$B$内变量的更改语句的集合\n  Control Flow\n 是 Forward Analysis，算法从Entry 跑到Exit 由于是 May Analysis，因此不会忽略任意一个分支  $$IN[B] = \\bigcup_{P\\ a\\ predecessor \\ of\\ B} OUT[P]$$\n  下图是龙书上 $gen_B$ 和 $kill_B$ 的例子   Algorithm of Reaching Definition Analysis 练习题  练习: 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$  Understanding the why the loop will definitely stop （理解算法的收敛性）   $gen_s$ 和 $kill_s$ 是常量\n  $IN[s]$ 每次增加的因子factor（这里指Definition）要么被$kill_s$ 要么被带入$OUT[s]$\n   于是$OUT[s]=f_s(IN[s])$ 单调不减 ($OUT[s]$要么0→1， 要么 1→1 ) 又由于factor本身是有限的 i.e. OUT[s]最多变成 1111…1111 就不变了。 类比一下数列的单调有界准则。  Understanding the safe-approximation （理解算法安全近似性）   当$OUT[s]$不再变化时，$IN[s]$是否会再次变化？\n答案是不会，由于\n$IN[B] = \\bigcup_{P\\ a\\ predecessor \\ of\\ B} OUT[P]$\n所有的$IN[B]$ 取决于 $OUT[P]$ 的值，于是$IN[B]$的值不变。\n$OUT[B] = gen_B \\cup (IN[B] - kill_B)$\n于是所有的 $OUT[s]$也不会改变。\n  练习：对以下CFG，利用Reaching Definition Analysis，计算各个BB最终的$IN$和$OUT$\n Live Variable Analysis Definition:  Live variable analysis tells whether the value of variable $v$ at program point $p$ could be used along some path in CFG starting at $p$. If so, $v$ is live at $p$；otherwise，$v$ is dead at $p$.\n (这也意味着：$v$ should not be redefined before usage)\n Application：  Register Allocation (寄存器分配）    Abstraction  Data Flow Values/Facts  All the variables in a program Can be represented by bit vectors  0: dead 1: live      Safe-Approximation   why forward analysis is not appropriate for live variable analysis?\n Assume we use forward analysis strategy, information of using should be propagate backward whenever a statement use $v$ is reached, which costs a lot. 我们利用反证法的思想：假设我们使用前向分析，变量使用的信息将会被向后传播，那还不如直接进行后向分析来的方便。    According to the definition, the live variable should be a may analysis.\n  understand the term ‘live’: determine whether the variable $v$ in some register $R$ is live, or should we delete the value of $v$ in $R$, at the point of $IN[B]$?\nIf Yes, $IN[B] = {v}$ else $IN[B] = {}$\n  由于是may analysis，Control Flow通过以下式子给出\n$$ OUT[B] = \\bigcup_{S\\ is\\ a successor\\ of\\ B} IN[S] $$\n  盲人摸象：我们通过以下一组练习，探索所有B关于$v$的表达式之情况，来探索出 Transfer Function\n练习：根据上图的CFG，并给定$OUT[B] = {v}$，考虑以下$B$的表达式对应的$IN[B]$\n k = n 2. k = v 3. v = v - 1 4. v = 2; k = v 5. k = v; v = 2 6. v = 2    *答案：\n k = n: 由于没有涉及到$v$，根据原则，寄存器$R$不应删去$v$的值，因此$IN[B] = {v}$ k = v : 由于涉及到use $v$，我们不应该删去$v$的值，因此$IN[B] = {v}$ v = v - 1 : 这题看似是对 $v$进行了新的定义，但是就语义而言，将会先对$v$的旧值进行读取，于是我们没有必要 kill 掉$v$，因此 $IN[B] = {v}$ v = 2; k = v ：这题看似使用了 $v$，但是先kill掉了$v$的定义，因此 $IN[B] = {}$ k = v; v = 2 ：*正好与上题相反，先对$v$进行了use，因此$IN[B] = {v}$ v = 2 ：$v$被kill掉，显然 $IN[b] = {v}$    先来回答集合中那些增减的量\n $use_B$：集合中在任何use先于define的变量集合。 $def_B$：集合中任何define先于use的变量集合。    于是，我们可以摸索出一个 Transfer Function\n$$ IN[B] = use_B \\cup(OUT[B]-def_B) $$\n  思考：kill $def_B$ 和 union $use_B$ 的顺序是否影响算法的正确性？\n结论：不影响，直觉上来看，根据$def_B$和$use_B$的定义，$def_B \\cap use_b = \\phi$\n不失严谨地，我们可以证明这个性质：\n【推论】\n已知 $def_B \\cap use_b = \\phi$， $IN[B] = use_B \\cup(OUT[B]-def_B) = (OUT[B] \\cup use_B) - def_B$ 成立\n【证明】\n考虑集合运算公式： $(B-A) \\cup C = (B\\cup C) - (A - C)$\n我们有：\n$$ IN[B] = use_B \\cup(OUT[B]-def_B) = (use_B \\cup OUT[B]) - (def_B - use_B) $$\n由于 $def_B \\cap use_b = \\phi$，于是有$def_B-use_B =def_B$\n那么，\n$$ (use_B \\cup OUT[B]) - (def_B - use_B)=(use_B \\cup OUT[B]) - def_B $$\n$\\blacksquare$\n  Algorithm 按照Reaching Definition Analysis的框架，不难得到。但是有一点不同：\n由于是BackWard Analysis，从Exit节点开始遍历。\n练习题  练习: 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$   Available Expression Analysis Definition Available:\nAn expression x op y is available at program point $p$ if\n All paths from the entry to p must pass through the evaluation of x op y After the last evaluation of x op y, there is no redefinition of x or y  Explanation:\n 这里的redefinition表明：原本的结果失效，我们可以需要更改 x op y 的结果值 available expression的信息可以用于检查全局相同的子表达式  比如，在某几个BB中表达式的值不变，我们就可以删去那个表达式，直接将缓存的结果赋给变量，优化掉重复计算。    Abstraction  All the expressions in a program Also represented by Bit Vectors  Safe-Approximation 注：\n As the definition illustrated, the available expression analysis ought to be a MUST ANALYSIS. As we are analyzing expression in all control flows, forward analysis is preferred to bring the information.  Transfer Function\n$gen_B$: Any expression included by $B$ to be involved.\n$kill_B$: Any expression contains variables redefined in $B$ to be excluded.\n我们可以得到Transfer Function：\n$$ OUT[B] = gen_B \\cup (IN[B]-kill_B) $$\nControl Flows\nFor it is a must analysis, control flow ought to defined by:\n$$ IN[B] = \\bigcap_{P\\ predecessor\\ of\\ B } OUT[P] $$\nAlgorithm  练习: 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$   Comparison for three data flow analysis 练习：根据以上的内容，填写下表（不要参考上面的材料）\n 答案：  ","wordCount":"1049","inLanguage":"en","datePublished":"2020-09-15T11:30:03Z","dateModified":"2020-09-15T11:30:03Z","author":{"@type":"Person","name":"Noobi"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-anlaysis-applications/"},"publisher":{"@type":"Organization","name":"名声，只是一种糟糕的错觉","logo":{"@type":"ImageObject","url":"https://jiayezheng.tech/images/sl.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://jiayezheng.tech/ accesskey=h title="名声，只是一种糟糕的错觉 (Alt + H)"><img src=https://jiayezheng.tech/images/sl.png alt=logo aria-label=logo height=35>名声，只是一种糟糕的错觉</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://jiayezheng.tech/aboutme/ title=关于我><span>关于我</span></a></li><li><a href=http://jiayezheng.tech/tags/ title=标签><span>标签</span></a></li><li><a href=https://jiayezheng.tech/ title=主页><span>主页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://jiayezheng.tech/>Home</a>&nbsp;»&nbsp;<a href=http://jiayezheng.tech/posts/>Posts</a></div><h1 class=post-title>【软件分析笔记】数据流分析：应用篇</h1><div class=post-description>介绍典型的数据流分析算法</div><div class=post-meta><span title="2020-09-15 11:30:03 +0000 UTC">September 15, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Noobi&nbsp;|&nbsp;<a href=https://github.com/Xpectuer/my-blog/content/posts/compilers/static-analysis/data-flow-analysis/data-flow-anlaysis-applications.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#data-flow-analysisapplications aria-label="Data Flow Analysis：Applications">Data Flow Analysis：Applications</a><ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#preliminaries-for-data-flow-analysis aria-label="Preliminaries for Data Flow Analysis">Preliminaries for Data Flow Analysis</a><ul><li><a href=#input--output-states aria-label="Input &amp;amp; Output States">Input & Output States</a></li><li><a href=#domain-%e5%80%bc%e5%9f%9f aria-label="Domain 值域">Domain 值域</a></li><li><a href=#data-flow-analysis-another-perspective aria-label="Data flow analysis: another perspective">Data flow analysis: another perspective</a></li><li><a href=#notations-for-transfer-functionss-constrains aria-label="Notations for Transfer Functions’s Constrains">Notations for Transfer Functions’s Constrains</a></li><li><a href=#notations-for-control-flows-constraints aria-label="Notations for Control Flow’s Constraints">Notations for Control Flow’s Constraints</a></li></ul></li><li><a href=#reaching-definitions-analysis aria-label="Reaching Definitions Analysis">Reaching Definitions Analysis</a><ul><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a></li><li><a href=#abstraction aria-label=Abstraction>Abstraction</a></li><li><a href=#safe-approximation aria-label=Safe-Approximation>Safe-Approximation</a></li><li><a href=#algorithm-of-reaching-definition-analysis aria-label="Algorithm of Reaching Definition Analysis">Algorithm of Reaching Definition Analysis</a></li><li><a href=#%e7%bb%83%e4%b9%a0%e9%a2%98 aria-label=练习题>练习题</a></li><li><a href=#understanding-the-why-the-loop-will-definitely-stop-%e7%90%86%e8%a7%a3%e7%ae%97%e6%b3%95%e7%9a%84%e6%94%b6%e6%95%9b%e6%80%a7 aria-label="Understanding the why the loop will definitely stop （理解算法的收敛性）">Understanding the why the loop will definitely stop （理解算法的收敛性）</a></li><li><a href=#understanding-the-safe-approximation-%e7%90%86%e8%a7%a3%e7%ae%97%e6%b3%95%e5%ae%89%e5%85%a8%e8%bf%91%e4%bc%bc%e6%80%a7 aria-label="Understanding the safe-approximation （理解算法安全近似性）">Understanding the safe-approximation （理解算法安全近似性）</a></li></ul></li><li><a href=#live-variable-analysis aria-label="Live Variable Analysis">Live Variable Analysis</a><ul><li><a href=#definition aria-label=Definition:><strong>Definition:</strong></a></li><li><a href=#abstraction-1 aria-label=Abstraction><strong>Abstraction</strong></a></li><li><a href=#safe-approximation-1 aria-label=Safe-Approximation><strong>Safe-Approximation</strong></a></li><li><a href=#algorithm aria-label=Algorithm>Algorithm</a></li><li><a href=#%e7%bb%83%e4%b9%a0%e9%a2%98-1 aria-label=练习题>练习题</a></li></ul></li><li><a href=#available-expression-analysis aria-label="Available Expression Analysis">Available Expression Analysis</a><ul><li><a href=#definition-1 aria-label=Definition>Definition</a></li><li><a href=#abstraction-2 aria-label=Abstraction>Abstraction</a></li><li><a href=#safe-approximation-2 aria-label=Safe-Approximation>Safe-Approximation</a></li><li><a href=#algorithm-1 aria-label=Algorithm>Algorithm</a></li><li><a href=#comparison-for-three-data-flow-analysis aria-label="Comparison for three data flow analysis">Comparison for three data flow analysis</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=data-flow-analysisapplications>Data Flow Analysis：Applications<a hidden class=anchor aria-hidden=true href=#data-flow-analysisapplications>#</a></h1><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>What is <em>Data Flow Analysis</em> ?</p><p>How application-specific Data flows on <strong>CFG</strong> with <strong>safe approximation</strong>.</p><p>分析算法感兴趣的数据如何流经控制流图。</p><ul><li><strong>CFG</strong><ul><li>Nodes (Basic Blocks) 基本块</li><li>Edges (Control Flow) 控制流</li><li>CFG(a program) 整个程序</li></ul></li><li>Safe Approximation</li></ul><p>safe approximation for <strong>different purposes 不同的分析目的，对于safe有不同的定义</strong>:</p><ul><li>Must Analysis：Under Approximation</li><li>May Analysis: Over Approximation</li></ul><p><strong>相同点</strong>：这两种目的往往殊途同归地达到Soundness。</p><p>不同的目的对应了不同的手段：1. Data Abstraction 2. Approximation Strategies i.e. <strong>transfer functions</strong> & <strong>control flow handling</strong>.</p><hr><h2 id=preliminaries-for-data-flow-analysis>Preliminaries for Data Flow Analysis<a hidden class=anchor aria-hidden=true href=#preliminaries-for-data-flow-analysis>#</a></h2><h3 id=input--output-states>Input & Output States<a hidden class=anchor aria-hidden=true href=#input--output-states>#</a></h3><p><strong>Definition</strong>:</p><p>$IN[s]\ OUT[s]$ stand for input & output states of program points i.e. before and after executing the IR statements $s$ respectively.</p><p>e.g.:</p><ul><li>下面是最简单的程序点的示意图。包括：<ol><li>$s_1$的输入/输出状态</li><li>$s_1$的语句</li><li>程序点，包括状态信息</li></ol></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_5B9834796776-1.jpeg alt=IMG_5B9834796776-1.jpeg style=zoom:50%><ul><li><p>语句之间的状态关系1：</p><p>下面表示两个顺序的语句之间状态关系。</p><p>即，$s_2$的输入是$s_1$的输出</p><p>$IN[s_2]=OUT[s_1]$</p></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_1264.jpg alt=IMG_1264.jpg style=zoom:50%><ul><li><p>带有控制流的语句间的状态关系1：</p><p>右图表示了一种分支语句的状态关系</p></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_39DFBE1DA174-1.jpeg alt=IMG_39DFBE1DA174-1.jpeg style=zoom:50%><ul><li><p>带有控制流的语句间的状态关系2：</p><p>下图是分支合并语句的状态关系，引入了操作符$\wedge$，表示语句分支的合并
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_1266.jpg alt=IMG_1266.jpg style=zoom:50%></p></li></ul><h3 id=domain-值域>Domain 值域<a hidden class=anchor aria-hidden=true href=#domain-值域>#</a></h3><blockquote><p>In each data-flow analysis application, we associate with every program point a data-flow value that represents abstraction of the set of all possible program states that can be observed for that point.</p></blockquote><p>data-flow value: <strong>Abstraction</strong> of the set of all possible <strong>program states</strong> that can be observed for that point.</p><p>于是，我们把 data flow value在一个程序中可能取值的集合称作 <strong>Domain.</strong></p><h3 id=data-flow-analysis-another-perspective>Data flow analysis: another perspective<a hidden class=anchor aria-hidden=true href=#data-flow-analysis-another-perspective>#</a></h3><p>Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the $IN[s]$ and $OUT[s]$, for all statements $s$.</p><ul><li>constraints<ul><li>transfer functions</li><li>flow of control</li></ul></li><li>solution<ul><li>related data flow value for each program points of statement $s$.</li></ul></li></ul><h3 id=notations-for-transfer-functionss-constrains>Notations for Transfer Functions’s Constrains<a hidden class=anchor aria-hidden=true href=#notations-for-transfer-functionss-constrains>#</a></h3><ul><li><strong>Forward Analysis</strong></li></ul><p>$OUT[s] = f_s(IN[s])$</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_6B0F10640944-1.jpeg alt=IMG_6B0F10640944-1.jpeg style=zoom:50%><ul><li><strong>Backward Analysis</strong></li></ul><p>$IN[s] = f_s(OUT[s])$</p><h3 id=notations-for-control-flows-constraints>Notations for Control Flow’s Constraints<a hidden class=anchor aria-hidden=true href=#notations-for-control-flows-constraints>#</a></h3><ul><li><p><strong>Control flow within a BB</strong></p><p>$IN[s_{i+1}]=OUT[s_i], \forall i=1,2,3,&mldr;,n-1$</p></li><li><p><strong>Control flow among BBs</strong></p><p>$IN[B] = IN[s_1]$</p><blockquote><p>注：BB的入口是BB<strong>第一个语句</strong>的<strong>入口</strong></p></blockquote><p>$OUT[B]=OUT[s_n]$</p><blockquote><p>注：BB的出口是BB<strong>最后一个语句</strong>的<strong>出口</strong></p></blockquote><p>$OUT[B] = f_B(IN[B]), f_B = f_{sn} \circ &mldr; \circ f_{s2} \circ f_{s1}$</p><blockquote><p>注：$\circ$ 表示函数的复合</p></blockquote><p>$IN[B]=\bigwedge_{\color{red}P\\ a\ predecessor\ of\ \color{blue} B}^{} OUT[P]$</p><blockquote><p>注：分支合并B的输入等于B所有前驱节点输出状态 <strong>meet 的结果</strong></p></blockquote></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_D7917E87C141-1.jpeg alt=IMG_D7917E87C141-1.jpeg style=zoom:50%>
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_2BDB7DCE680A-1.jpeg alt=IMG_2BDB7DCE680A-1.jpeg style=zoom:50%><hr><h2 id=reaching-definitions-analysis>Reaching Definitions Analysis<a hidden class=anchor aria-hidden=true href=#reaching-definitions-analysis>#</a></h2><p><strong>Definition:</strong></p><p>A statement that assign a value to $v$. 一条对$v$的赋值语句。</p><p><strong>Reaching Definition:</strong></p><blockquote><p>Definition of variable $v$ at program point $p$ reaches point $q$ if there is a path from p to $q$ s.t. <strong>no new definition of</strong> $v$ appears on that path.</p></blockquote><p><strong>Reaching Definition</strong>：变量$v$在从程序点$p$到程序点 $q$到过程中未被重新定义。</p><h3 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h3><ul><li><p>Detecting possible undefined variables. 检查undefined变量</p><p>E.g.: Introduce a <strong>dummy definition</strong> for each variable. If any at point $p$, definition of variable $v$ is dummy, then it is <strong>undefined</strong>.</p><p>e.g.: Application in Optimization: Check if the variable</p></li></ul><h3 id=abstraction>Abstraction<a hidden class=anchor aria-hidden=true href=#abstraction>#</a></h3><ul><li><p>Data Flow Values / Facts</p><ul><li>The definition of all the variables in a program.</li><li>represented by <strong>Bit Vectors</strong></li></ul><p>e.g.: $D_1, D_2, D_3, &mldr;, D_{100}$ (100 definitions)</p><pre><code>[ 0000...0 ] &lt;——(100 bits)
</code></pre><p>Bit $i$ from the left represents definition $D_i$</p></li></ul><h3 id=safe-approximation>Safe-Approximation<a hidden class=anchor aria-hidden=true href=#safe-approximation>#</a></h3><p>考虑语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>D: v <span style=color:#f92672>=</span> x op y
</span></span></code></pre></div><p>本条语句将程序中 $v$ 的其他定义<strong>去除</strong>，其他变量的定义不受影响。</p><ul><li><p><strong>Transfer function 数学语言表达</strong></p><p>$$OUT[B] = gen_B \cup (IN[B] - kill_B)$$</p><p>其中$gen_B$基本块$B$产生的definition的<strong>集合</strong></p><p>$kill_B$代表所有$B$以外基本块对$B$内变量的更改语句的<strong>集合</strong></p></li><li><p><strong>Control Flow</strong></p><ul><li>是 Forward Analysis，算法从Entry 跑到Exit</li><li>由于是 May Analysis，因此不会忽略任意一个分支</li></ul><p>$$IN[B] = \bigcup_{P\ a\ predecessor \ of\ B} OUT[P]$$</p></li><li><p>下图是龙书上 $gen_B$ 和 $kill_B$ 的例子
<img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_C1B6C8D6DC93-1.jpeg alt=IMG_C1B6C8D6DC93-1.jpeg style=zoom:50%></p></li></ul><h3 id=algorithm-of-reaching-definition-analysis>Algorithm of Reaching Definition Analysis<a hidden class=anchor aria-hidden=true href=#algorithm-of-reaching-definition-analysis>#</a></h3><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/reaching_def.png alt="reaching definition algorithm"><h3 id=练习题>练习题<a hidden class=anchor aria-hidden=true href=#练习题>#</a></h3><ul><li><strong>练习:</strong> 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$</li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-03_%E4%B8%8B%E5%8D%8810.59.42.png alt="截屏2022-01-03 下午10.59.42.png" style=zoom:50%><h3 id=understanding-the-why-the-loop-will-definitely-stop-理解算法的收敛性>Understanding the why the loop will definitely stop （理解算法的收敛性）<a hidden class=anchor aria-hidden=true href=#understanding-the-why-the-loop-will-definitely-stop-理解算法的收敛性>#</a></h3><ul><li><p>$gen_s$ 和 $kill_s$ 是常量</p></li><li><p>$IN[s]$ 每次增加的<strong>因子factor</strong>（这里指<strong>Definition</strong>）要么被$kill_s$ 要么被带入$OUT[s]$</p></li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_06A792AB1F78-1.jpeg alt=IMG_06A792AB1F78-1.jpeg style=zoom:50%><ul><li>于是$OUT[s]=f_s(IN[s])$ 单调不减 ($OUT[s]$要么0→1， 要么 1→1 )</li><li>又由于factor本身是<strong>有限的</strong> i.e. OUT[s]最多变成 1111&mldr;1111 就不变了。</li><li>类比一下数列的单调有界准则。</li></ul><h3 id=understanding-the-safe-approximation-理解算法安全近似性>Understanding the safe-approximation （理解算法安全近似性）<a hidden class=anchor aria-hidden=true href=#understanding-the-safe-approximation-理解算法安全近似性>#</a></h3><ul><li><p>当$OUT[s]$不再变化时，$IN[s]$是否会再次变化？</p><p>答案是<strong>不会</strong>，由于</p><p>$IN[B] = \bigcup_{P\ a\ predecessor \ of\ B} OUT[P]$</p><p>所有的$IN[B]$ 取决于 $OUT[P]$ 的值，于是$IN[B]$的值不变。</p><p>$OUT[B] = gen_B \cup (IN[B] - kill_B)$</p><p>于是所有的 $OUT[s]$也不会改变。</p></li></ul><p>练习：对以下CFG，利用Reaching Definition Analysis，计算各个BB最终的$IN$和$OUT$</p><hr><h2 id=live-variable-analysis>Live Variable Analysis<a hidden class=anchor aria-hidden=true href=#live-variable-analysis>#</a></h2><h3 id=definition><strong>Definition:</strong><a hidden class=anchor aria-hidden=true href=#definition>#</a></h3><blockquote><p>Live variable analysis tells whether the value of variable $v$ at program point $p$ could be used along some path in CFG starting at $p$. If so, $v$ is live at $p$；otherwise，$v$ is dead at $p$.</p></blockquote><p>(这也意味着：$v$ should not be redefined <strong>before usage</strong>)</p><ul><li>Application：<ul><li><strong>Register Allocation (寄存器分配）</strong></li></ul></li></ul><h3 id=abstraction-1><strong>Abstraction</strong><a hidden class=anchor aria-hidden=true href=#abstraction-1>#</a></h3><ul><li>Data Flow Values/Facts<ul><li>All the <strong>variables</strong> in a program</li><li>Can be represented by <strong>bit vectors</strong><ul><li>0: dead 1: live</li></ul></li></ul></li></ul><h3 id=safe-approximation-1><strong>Safe-Approximation</strong><a hidden class=anchor aria-hidden=true href=#safe-approximation-1>#</a></h3><ul><li><p>why <strong>forward analysis</strong> is not appropriate for live variable analysis?</p><ul><li>Assume we use forward analysis strategy, information of using should be propagate backward whenever a statement use $v$ is reached, which costs a lot.</li><li>我们利用反证法的思想：假设我们使用前向分析，变量使用的信息将会被向后传播，那还不如直接进行后向分析来的方便。</li></ul></li><li><p>According to the definition, the live variable should be a may analysis.</p></li><li><p><strong>understand the term ‘live’:</strong> determine whether the variable $v$ in some register $R$ is live, or should we delete the value of $v$ in $R$, at the point of $IN[B]$?</p><p>If Yes, $IN[B] = {v}$ else $IN[B] = {}$</p></li></ul><p>由于是may analysis，<strong>Control Flow</strong>通过以下式子给出</p><p>$$
OUT[B] = \bigcup_{S\ is\ a successor\ of\ B} IN[S]
$$</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/IMG_1276.jpg alt=IMG_1276.jpg style=zoom:50%><ul><li><p><strong>盲人摸象</strong>：我们通过以下一组练习，探索所有B关于$v$的表达式之情况，来探索出 Transfer Function</p><p>练习：根据上图的CFG，并给定$OUT[B] = {v}$，考虑以下$B$的表达式对应的$IN[B]$</p><ol><li><code>k = n</code> 2. <code>k = v</code> 3. <code>v = v - 1</code> 4. <code>v = 2; k = v</code> 5. <code>k = v; v = 2</code> 6. <code>v = 2</code></li></ol></li><li><p>*答案：</p><ol><li><code>k = n</code>: 由于没有涉及到$v$，根据原则，寄存器$R$不应删去$v$的值，因此$IN[B] = {v}$</li><li><code>k = v</code> : 由于涉及到use $v$，我们不应该删去$v$的值，因此$IN[B] = {v}$</li><li><code>v = v - 1</code> : 这题看似是对 $v$进行了新的定义，但是就语义而言，将会先对$v$的旧值进行读取，于是我们没有必要 kill 掉$v$，因此 $IN[B] = {v}$</li><li><code>v = 2; k = v</code> ：这题看似使用了 $v$，但是先kill掉了$v$的定义，因此 $IN[B] = {}$</li><li><code>k = v; v = 2</code> ：*正好与上题相反，先对$v$进行了use，因此$IN[B] = {v}$</li><li><code>v = 2</code> ：$v$被kill掉，显然 $IN[b] = {v}$</li></ol></li><li><p>先来回答集合中那些<strong>增减</strong>的量</p><ul><li>$use_B$：集合中在<strong>任何use先于define</strong>的变量集合。</li><li>$def_B$：集合中<strong>任何define先于use</strong>的变量集合。</li></ul></li><li><p>于是，我们可以摸索出一个 <strong>Transfer Function</strong></p><p>$$
IN[B] = use_B \cup(OUT[B]-def_B)
$$</p></li><li><p>思考：kill $def_B$ 和 union $use_B$ 的顺序是否影响算法的正确性？</p><p>结论：不影响，直觉上来看，根据$def_B$和$use_B$的定义，$def_B \cap use_b = \phi$</p><p>不失严谨地，我们可以证明这个性质：</p><p>【推论】</p><p>已知 $def_B \cap use_b = \phi$， $IN[B] = use_B \cup(OUT[B]-def_B) = (OUT[B] \cup use_B) - def_B$ 成立</p><p>【证明】</p><p>考虑集合运算公式： $(B-A) \cup C = (B\cup C) - (A - C)$</p><p>我们有：</p><p>$$
IN[B] = use_B \cup(OUT[B]-def_B) = (use_B \cup OUT[B]) - (def_B - use_B)
$$</p><p>由于 $def_B \cap use_b = \phi$，于是有$def_B-use_B =def_B$</p><p>那么，</p><p>$$
(use_B \cup OUT[B]) - (def_B - use_B)=(use_B \cup OUT[B]) - def_B
$$</p><p>$\blacksquare$</p></li></ul><h3 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h3><p>按照Reaching Definition Analysis的框架，不难得到。但是有一点不同：</p><p>由于是BackWard Analysis，从Exit节点开始遍历。</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/live_var.png alt="live variable algorithm"><h3 id=练习题-1>练习题<a hidden class=anchor aria-hidden=true href=#练习题-1>#</a></h3><ul><li><strong>练习:</strong> 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$</li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-03_%E4%B8%8B%E5%8D%8811.28.34.png alt="截屏2022-01-03 下午11.28.34.png" style=zoom:50%><hr><h2 id=available-expression-analysis>Available Expression Analysis<a hidden class=anchor aria-hidden=true href=#available-expression-analysis>#</a></h2><h3 id=definition-1>Definition<a hidden class=anchor aria-hidden=true href=#definition-1>#</a></h3><p><strong>Available:</strong></p><p>An expression <code>x op y</code> is <strong>available</strong> at program point $p$ if</p><ol><li>All paths from the entry to p must pass through the evaluation of <code>x op y</code></li><li>After the last evaluation of x op y, there is <strong>no redefinition</strong> of <code>x</code> or <code>y</code></li></ol><p><strong>Explanation:</strong></p><ul><li>这里的redefinition表明：原本的结果失效，我们可以需要更改 <code>x op y</code> 的结果值</li><li>available expression的信息可以用于检查全局相同的子表达式<ul><li>比如，在某几个BB中表达式的值不变，我们就可以删去那个表达式，直接将缓存的结果赋给变量，<strong>优化掉</strong>重复计算。</li></ul></li></ul><h3 id=abstraction-2>Abstraction<a hidden class=anchor aria-hidden=true href=#abstraction-2>#</a></h3><ul><li>All the expressions in a program</li><li>Also represented by Bit Vectors</li></ul><h3 id=safe-approximation-2>Safe-Approximation<a hidden class=anchor aria-hidden=true href=#safe-approximation-2>#</a></h3><p>注：</p><ol><li>As the definition illustrated, the available expression analysis ought to be a <strong>MUST ANALYSIS.</strong></li><li>As we are analyzing expression in all control flows, <strong>forward analysis</strong> is preferred to bring the information.</li></ol><p><strong>Transfer Function</strong></p><p>$gen_B$: Any expression included by $B$ to be involved.</p><p>$kill_B$: Any expression contains variables redefined in $B$ to be excluded.</p><p>我们可以得到Transfer Function：</p><p>$$
OUT[B] = gen_B \cup (IN[B]-kill_B)
$$</p><p><strong>Control Flows</strong></p><p>For it is a must analysis, control flow ought to defined by:</p><p>$$
IN[B] = \bigcap_{P\ predecessor\ of\ B } OUT[P]
$$</p><h3 id=algorithm-1>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm-1>#</a></h3><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/available_exp.png alt="available expression algorithm"><ul><li><strong>练习:</strong> 对以下CFG执行 **Reaching Definition Analysis，**给出最终的$IN$和$OUT$</li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-04_%E4%B8%8B%E5%8D%882.09.17.png alt="截屏2022-01-04 下午2.09.17.png" style=zoom:50%><hr><h3 id=comparison-for-three-data-flow-analysis>Comparison for three data flow analysis<a hidden class=anchor aria-hidden=true href=#comparison-for-three-data-flow-analysis>#</a></h3><p><strong>练习</strong>：根据以上的内容，填写下表（不要参考上面的材料）</p><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-04_%E4%B8%8B%E5%8D%882.13.06.png alt="截屏2022-01-04 下午2.13.06.png" style=zoom:50%><ul><li>答案：</li></ul><img src=http://jiayezheng.tech//posts/compilers/static-analysis/data-flow-analysis/images/%E6%88%AA%E5%B1%8F2022-01-04_%E4%B8%8B%E5%8D%882.19.11.png alt="截屏2022-01-04 下午2.19.11.png" style=zoom:50%></div><footer class=post-footer><ul class=post-tags><li><a href=http://jiayezheng.tech/tags/static-analysis/>static analysis</a></li></ul><nav class=paginav><a class=prev href=http://jiayezheng.tech/posts/compilers/static-analysis/data-flow-analysis/data-flow-analysis-foundations/><span class=title>« Prev Page</span><br><span>【软件分析笔记】数据流分析：基础与原理篇</span></a>
<a class=next href=http://jiayezheng.tech/posts/leetcode/miscs/390/><span class=title>Next Page »</span><br><span>LC390.消除游戏</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://jiayezheng.tech/>名声，只是一种糟糕的错觉</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>